import 'package:bcrypt/bcrypt.dart';
import '../models/user_model.dart';
import '../services/user_service.dart';

class AuthRepository {
  final UserService _userService;

  UserModel? _currentUser;

  AuthRepository(this._userService);

  UserModel? get currentUser => _currentUser;

  // =====================================================
  // REGISTER
  // =====================================================
  Future<UserModel> register({
    required String email,
    required String password,
    required String displayName,
  }) async {
    final existing = await _userService.getUserByEmail(email);

    if (existing != null) {
      throw Exception('Email already registered');
    }

    final hash = BCrypt.hashpw(password, BCrypt.gensalt());

    final response = await _userService.createUser(
      email: email,
      passwordHash: hash,
      displayName: displayName,
    );

    final user = UserModel.fromJson(response);

    _currentUser = user;

    return user;
  }

  // =====================================================
  // LOGIN
  // =====================================================
  Future<UserModel> login({
    required String email,
    required String password,
  }) async {
    final response = await _userService.getUserByEmail(email);

    if (response == null) {
      throw Exception('User not found');
    }

    final passwordHash = response['password_hash'] as String;

    final isValid = BCrypt.checkpw(password, passwordHash);

    if (!isValid) {
      throw Exception('Invalid credentials');
    }

    // Fetch full fresh user from DB
    final userId = response['id'] as String;
    final fullUser = await _userService.getUserById(userId);

    if (fullUser == null) {
      throw Exception('User data missing');
    }

    final user = UserModel.fromJson(fullUser);

    _currentUser = user;

    return user;
  }

  // =====================================================
  // LOGOUT
  // =====================================================
  Future<void> logout() async {
    _currentUser = null;
  }
}
import 'dart:io';
import 'package:uuid/uuid.dart';

import '../models/comment_model.dart';
import '../services/comment_service.dart';
import '../services/comment_image_service.dart';
import '../services/storage_service.dart';

class CommentRepository {
  final CommentService _commentService;
  final StorageService _storageService;
  final CommentImageService _commentImageService;

  CommentRepository(
    this._commentService,
    this._storageService,
    this._commentImageService,
  );

  final _uuid = const Uuid();

  // =========================================================
  // READ
  // =========================================================
  Future<List<CommentModel>> fetchComments({
    required String postId,
    required int limit,
    required int offset,
  }) async {
    final data = await _commentService.fetchComments(
      postId: postId,
      limit: limit,
      offset: offset,
    );

    return data.map(CommentModel.fromJson).toList();
  }

  Future<CommentModel> fetchCommentById(String id) async {
    final data = await _commentService.fetchCommentById(id);
    return CommentModel.fromJson(data);
  }

  // =========================================================
  // CREATE
  // =========================================================
  Future<CommentModel> createComment({
    required String postId,
    required String authorId,
    required String content,
    required List<File> images,
  }) async {
    final comment = await _commentService.createComment(
      postId: postId,
      authorId: authorId,
      content: content,
    );

    final commentId = comment['id'] as String;

    if (images.isNotEmpty) {
      await Future.wait(
        images.map((file) async {
          final path = '$commentId/${_uuid.v4()}.jpg';

          final url = await _storageService.uploadFile(
            bucket: 'comment-images',
            path: path,
            file: file,
          );

          await _commentImageService.insertCommentImage(
            commentId: commentId,
            url: url,
          );
        }),
      );
    }

    return fetchCommentById(commentId);
  }

  // =========================================================
  // UPDATE (Partial Image Support)
  // =========================================================
  Future<CommentModel> updateComment({
    required String commentId,
    required String content,
    List<String>? imageIdsToDelete,
    List<File>? newImages,
  }) async {
    await _commentService.updateComment(commentId, {'content': content});

    // Delete selected images
    if (imageIdsToDelete != null && imageIdsToDelete.isNotEmpty) {
      final images = await _commentImageService.fetchImagesByCommentId(
        commentId,
      );

      final imagesToRemove = images
          .where((img) => imageIdsToDelete.contains(img['id']))
          .toList();

      final paths = imagesToRemove
          .map((img) {
            final url = img['url'] as String;
            final uri = Uri.parse(url);
            final segments = uri.pathSegments;
            final bucketIndex = segments.indexOf('comment-images');
            if (bucketIndex == -1) return null;
            return segments.sublist(bucketIndex + 1).join('/');
          })
          .whereType<String>()
          .toList();

      if (paths.isNotEmpty) {
        await _storageService.deleteFiles(
          bucket: 'comment-images',
          paths: paths,
        );
      }

      for (final id in imageIdsToDelete) {
        await _commentImageService.deleteImageById(id);
      }
    }

    // Add new images
    if (newImages != null && newImages.isNotEmpty) {
      await Future.wait(
        newImages.map((file) async {
          final path = '$commentId/${_uuid.v4()}.jpg';

          final url = await _storageService.uploadFile(
            bucket: 'comment-images',
            path: path,
            file: file,
          );

          await _commentImageService.insertCommentImage(
            commentId: commentId,
            url: url,
          );
        }),
      );
    }

    return fetchCommentById(commentId);
  }

  // =========================================================
  // DELETE
  // =========================================================
  Future<void> deleteComment(String commentId) async {
    final images = await _commentImageService.fetchImagesByCommentId(commentId);

    final paths = images
        .map((img) {
          final url = img['url'] as String;
          final uri = Uri.parse(url);
          final segments = uri.pathSegments;
          final bucketIndex = segments.indexOf('comment-images');
          if (bucketIndex == -1) return null;
          return segments.sublist(bucketIndex + 1).join('/');
        })
        .whereType<String>()
        .toList();

    if (paths.isNotEmpty) {
      await _storageService.deleteFiles(bucket: 'comment-images', paths: paths);
    }

    await _commentImageService.deleteImagesByCommentId(commentId);
    await _commentService.deleteComment(commentId);
  }
}
import 'dart:io';

import '../models/post_model.dart';
import '../services/post_image_service.dart';
import '../services/post_service.dart';
import '../services/storage_service.dart';

class PostRepository {
  final PostService _postService;
  final StorageService _storageService;
  final PostImageService _postImageService;

  PostRepository(
    this._postService,
    this._storageService,
    this._postImageService,
  );

  // =========================================================
  // READ - Fetch posts (limit + offset for infinite scroll)
  // =========================================================

  Future<List<PostModel>> fetchPosts({
    required int limit,
    required int offset,
  }) async {
    final data = await _postService.fetchPosts(limit: limit, offset: offset);

    return data.map((e) => PostModel.fromJson(e)).toList();
  }

  // =========================================================
  // READ - Fetch single post
  // =========================================================

  Future<PostModel> fetchPostById(String postId) async {
    final data = await _postService.fetchPostById(postId);
    return PostModel.fromJson(data);
  }

  // =========================================================
  // CREATE - Post with images
  // =========================================================

  Future<PostModel> createPost({
    required String authorId,
    required String title,
    required String content,
    required List<File> images,
  }) async {
    // 1️⃣ Create post first
    final post = await _postService.createPost(
      authorId: authorId,
      title: title,
      content: content,
    );

    final postId = post['id'] as String;

    // 2️⃣ Upload images
    for (final file in images) {
      final path = '$postId/${DateTime.now().millisecondsSinceEpoch}.jpg';

      final url = await _storageService.uploadFile(
        bucket: 'post-images',
        path: path,
        file: file,
      );

      await _postImageService.insertPostImage(postId: postId, url: url);
    }

    // 3️⃣ Return fresh joined post
    return await fetchPostById(postId);
  }

  // =========================================================
  // UPDATE - Post (optionally replace images)
  // =========================================================

  Future<PostModel> updatePost({
    required String postId,
    required String title,
    required String content,
    List<String>? imageIdsToDelete,
    List<File>? newImages,
  }) async {
    // 1️⃣ Update text fields
    await _postService.updatePost(postId, {'title': title, 'content': content});

    // =========================================================
    // 2️⃣ Delete selected images
    // =========================================================
    if (imageIdsToDelete != null && imageIdsToDelete.isNotEmpty) {
      final images = await _postImageService.fetchImagesByPostId(postId);

      final imagesToRemove = images
          .where((img) => imageIdsToDelete.contains(img['id']))
          .toList();

      final paths = imagesToRemove
          .map((img) {
            final url = img['url'] as String;
            final uri = Uri.parse(url);
            final segments = uri.pathSegments;
            final bucketIndex = segments.indexOf('post-images');

            if (bucketIndex == -1) return null;

            return segments.sublist(bucketIndex + 1).join('/');
          })
          .whereType<String>()
          .toList();

      if (paths.isNotEmpty) {
        await _storageService.deleteFiles(bucket: 'post-images', paths: paths);
      }

      for (final id in imageIdsToDelete) {
        await _postImageService.deleteImageById(id);
      }
    }

    // =========================================================
    // 3️⃣ Add new images
    // =========================================================
    if (newImages != null && newImages.isNotEmpty) {
      await Future.wait(
        newImages.map((file) async {
          final path = '$postId/${DateTime.now().millisecondsSinceEpoch}.jpg';

          final url = await _storageService.uploadFile(
            bucket: 'post-images',
            path: path,
            file: file,
          );

          await _postImageService.insertPostImage(postId: postId, url: url);
        }),
      );
    }

    return await fetchPostById(postId);
  }
  // =========================================================
  // DELETE - Post (with storage cleanup)
  // =========================================================

  Future<void> deletePost(String postId) async {
    // 1️⃣ Fetch image records
    final images = await _postImageService.fetchImagesByPostId(postId);

    // 2️⃣ Extract storage paths
    final paths = images
        .map((img) {
          final url = img['url'] as String;
          final uri = Uri.parse(url);
          final segments = uri.pathSegments;
          final bucketIndex = segments.indexOf('post-images');

          if (bucketIndex == -1) return null;

          return segments.sublist(bucketIndex + 1).join('/');
        })
        .whereType<String>()
        .toList();

    // 3️⃣ Delete storage files
    await _storageService.deleteFiles(bucket: 'post-images', paths: paths);

    // 4️⃣ Delete post (DB cascade removes image rows)
    await _postService.deletePost(postId);
  }
}
import 'dart:io';

import '../models/user_model.dart';
import '../services/user_service.dart';
import '../services/storage_service.dart';

class UserRepository {
  final UserService _userService;
  final StorageService _storageService;

  UserRepository(this._userService, this._storageService);

  Future<UserModel> updateProfile({
    required String userId,
    String? displayName,
    String? bio,
  }) async {
    await _userService.updateUser(userId, {
      if (displayName != null) 'display_name': displayName,
      if (bio != null) 'bio': bio,
    });

    final updated = await _userService.getUserById(userId);
    return UserModel.fromJson(updated!);
  }

  Future<String> uploadAvatar({
    required String userId,
    required File file,
  }) async {
    final path = '$userId/avatar_${DateTime.now().millisecondsSinceEpoch}.jpg';

    final url = await _storageService.uploadFile(
      bucket: 'avatars',
      path: path,
      file: file,
    );

    await _userService.updateUser(userId, {'avatar_url': url});

    return url;
  }
}
